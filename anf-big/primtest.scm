(letrec ((square (lambda (x) (* x x)))) (letrec ((modulo-power (lambda (base exp n) (let ((_1 (= exp 0))) (if _1 1 (let ((_2 (odd? exp))) (if _2 (let ((_3 (- exp 1))) (let ((_4 (modulo-power base _3 n))) (let ((_5 (* base _4))) (let ((_6 (modulo _5 n))) _6)))) (let ((_7 (/ exp 2))) (let ((_8 (modulo-power base _7 n))) (let ((_9 (square _8))) (let ((_10 (modulo _9 n))) _10))))))))))) (letrec ((is-trivial-composite? (lambda (n) (let ((_11 (modulo n 2))) (let ((_12 (= _11 0))) (let ((_13 (modulo n 3))) (let ((_14 (= _13 0))) (let ((_15 (modulo n 5))) (let ((_16 (= _15 0))) (let ((_17 (modulo n 7))) (let ((_18 (= _17 0))) (let ((_19 (modulo n 11))) (let ((_20 (= _19 0))) (let ((_21 (modulo n 13))) (let ((_22 (= _21 0))) (let ((_23 (modulo n 17))) (let ((_24 (= _23 0))) (let ((_25 (modulo n 19))) (let ((_26 (= _25 0))) (let ((_27 (modulo n 23))) (let ((_28 (= _27 0))) (let ((_29 (or _12 _14 _16 _18 _20 _22 _24 _26 _28))) _29)))))))))))))))))))))) (letrec ((is-fermat-prime? (lambda (n iterations) (let ((_30 (<= iterations 0))) (let ((_31 (or _30 (let* ((byte-size (ceiling (/ (log n) (log 2)))) (a (random byte-size))) (if (= (modulo-power a (- n 1) n) 1) (is-fermat-prime? n (- iterations 1)) #f))))) _31))))) (letrec ((generate-fermat-prime (lambda (byte-size iterations) (let ((_32 (random byte-size))) (let ((n _32)) (let ((_33 (is-trivial-composite? n))) (let ((_34 (not _33))) (let ((_35 (is-fermat-prime? n iterations))) (let ((_36 (and _34 _35))) (if _36 n (generate-fermat-prime byte-size iterations))))))))))) (let ((iterations 10)) (let ((byte-size 15)) (generate-fermat-prime byte-size iterations))))))))