;; Expected result: #t
(letrec ((extended-gcd (lambda (a b) (let ((_30 (modulo a b))) (let ((_31 (= _30 0))) (if _31 (cons 0 1) (let ((_32 (modulo a b))) (let ((_33 (extended-gcd b _32))) (let ((x:y _33)) (let ((_34 (car x:y))) (let ((x _34)) (let ((_35 (cdr x:y))) (let ((y _35)) (let ((_41 (quotient a b))) (let ((_38 _41)) (let ((_36 _38)) (let ((_42 (* y _36))) (let ((_39 _42)) (let ((_37 _39)) (let ((_43 (- x _37))) (let ((_40 _43)) (let ((_44 (cons y _40))) _44)))))))))))))))))))))) (letrec ((modulo-inverse (lambda (a n) (let ((_47 (extended-gcd a n))) (let ((_45 _47)) (let ((_48 (car _45))) (let ((_46 _48)) (let ((_49 (modulo _46 n))) _49)))))))) (letrec ((totient (lambda (p q) (let ((_50 (- p 1))) (let ((_51 (- q 1))) (let ((_52 (* _50 _51))) _52)))))) (letrec ((square (lambda (x) (* x x)))) (letrec ((modulo-power (lambda (base exp n) (let ((_53 (= exp 0))) (if _53 1 (let ((_54 (odd? exp))) (if _54 (let ((_60 (- exp 1))) (let ((_57 _60)) (let ((_55 _57)) (let ((_61 (modulo-power base _55 n))) (let ((_58 _61)) (let ((_56 _58)) (let ((_62 (* base _56))) (let ((_59 _62)) (let ((_63 (modulo _59 n))) _63))))))))) (let ((_69 (/ exp 2))) (let ((_66 _69)) (let ((_64 _66)) (let ((_70 (modulo-power base _64 n))) (let ((_67 _70)) (let ((_65 _67)) (let ((_71 (square _65))) (let ((_68 _71)) (let ((_72 (modulo _68 n))) _72)))))))))))))))) (letrec ((is-legal-public-exponent? (lambda (e p q) (let ((_80 (< 1 e))) (let ((_81 (totient p q))) (let ((_73 _81)) (let ((_82 (< e _73))) (let ((_74 _82)) (let ((_83 (totient p q))) (let ((_77 _83)) (let ((_75 _77)) (let ((_84 (gcd e _75))) (let ((_78 _84)) (let ((_76 _78)) (let ((_85 (= 1 _76))) (let ((_79 _85)) (let ((_86 (and _80 _74 _79))) _86))))))))))))))))) (letrec ((private-exponent (lambda (e p q) (let ((_87 (is-legal-public-exponent? e p q))) (if _87 (let ((_88 (totient p q))) (let ((_89 (modulo-inverse e _88))) _89)) (error "Not a legal public exponent for that modulus.")))))) (letrec ((encrypt (lambda (m e n) (let ((_90 (> m n))) (if _90 (error "The modulus is too small to encrypt the message.") (modulo-power m e n)))))) (letrec ((decrypt (lambda (c d n) (modulo-power c d n)))) (let ((p 41)) (let ((q 47)) (let ((_91 (* p q))) (let ((n _91)) (let ((e 7)) (let ((_92 (private-exponent e p q))) (let ((d _92)) (let ((plaintext 42)) (let ((_93 (encrypt plaintext e n))) (let ((ciphertext _93)) (let ((_94 (decrypt ciphertext d n))) (let ((decrypted-ciphertext _94)) (= plaintext decrypted-ciphertext))))))))))))))))))))))
