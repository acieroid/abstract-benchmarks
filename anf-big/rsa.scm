'(letrec ((extended-gcd (lambda (a b) (let ((_1 (modulo a b))) (let ((_2 (= _1 0))) (if _2 (cons 0 1) (let ((_3 (modulo a b))) (let ((_4 (extended-gcd b _3))) (let ((x:y _4)) (let ((_5 (car x:y))) (let ((x _5)) (let ((_6 (cdr x:y))) (let ((y _6)) (let ((_7 (quotient a b))) (let ((_8 (* y _7))) (let ((_9 (- x _8))) (let ((_10 (cons y _9))) _10))))))))))))))))) (letrec ((modulo-inverse (lambda (a n) (let ((_11 (extended-gcd a n))) (let ((_12 (car _11))) (let ((_13 (modulo _12 n))) _13)))))) (letrec ((totient (lambda (p q) (let ((_14 (- p 1))) (let ((_15 (- q 1))) (let ((_16 (* _14 _15))) _16)))))) (letrec ((square (lambda (x) (* x x)))) (letrec ((modulo-power (lambda (base exp n) (let ((_17 (= exp 0))) (if _17 1 (let ((_18 (odd? exp))) (if _18 (let ((_19 (- exp 1))) (let ((_20 (modulo-power base _19 n))) (let ((_21 (* base _20))) (let ((_22 (modulo _21 n))) _22)))) (let ((_23 (/ exp 2))) (let ((_24 (modulo-power base _23 n))) (let ((_25 (square _24))) (let ((_26 (modulo _25 n))) _26))))))))))) (letrec ((is-legal-public-exponent? (lambda (e p q) (let ((_27 (< 1 e))) (let ((_28 (totient p q))) (let ((_29 (< e _28))) (let ((_30 (totient p q))) (let ((_31 (gcd e _30))) (let ((_32 (= 1 _31))) (let ((_33 (and _27 _29 _32))) _33)))))))))) (letrec ((private-exponent (lambda (e p q) (let ((_34 (is-legal-public-exponent? e p q))) (if _34 (let ((_35 (totient p q))) (let ((_36 (modulo-inverse e _35))) _36)) (error "Not a legal public exponent for that modulus.")))))) (letrec ((encrypt (lambda (m e n) (let ((_37 (> m n))) (if _37 (error "The modulus is too small to encrypt the message.") (modulo-power m e n)))))) (letrec ((decrypt (lambda (c d n) (modulo-power c d n)))) (let ((p 41)) (let ((q 47)) (let ((_38 (* p q))) (let ((n _38)) (let ((e 7)) (let ((_39 (private-exponent e p q))) (let ((d _39)) (let ((plaintext 42)) (let ((_40 (encrypt plaintext e n))) (let ((ciphertext _40)) (let ((_41 (decrypt ciphertext d n))) (let ((decrypted-ciphertext _41)) (= plaintext decrypted-ciphertext))))))))))))))))))))))
